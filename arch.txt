‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ         Usu√°rios          ‚îÇ
‚îÇ      (navegador web)      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
              ‚îÇ HTTPS
              ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  üü© Streamlit Cloud (Dashboard)  ‚îÇ
‚îÇ  API_BASE ‚Üí https://...render..  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
              ‚îÇ HTTP/JSON
              ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  üüß FastAPI (Render)                                           ‚îÇ
‚îÇ  uvicorn app.api:app   ‚Ä¢   CORS: https://*.streamlit.app      ‚îÇ
‚îÇ  Endpoints: /ingest, /ingest_batch, /batch/status, /batch/stop‚îÇ
‚îÇ             /data/last, /train, /predict, /                  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
              ‚îÇ DB_URL (psycopg3+SSL) ‚îÇ /ingest (coleta pre√ßo)
              ‚ñº                       ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  üü® Neon PostgreSQL       ‚îÇ   ‚îÇ  üü¶ CoinGecko API        ‚îÇ
‚îÇ  pooler gerenciado (SSL) ‚îÇ   ‚îÇ  /simple/price (BTC/USD) ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò


                    (CI/CD)
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê        push/pull request        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  üü• GitHub Repo (main)    ‚îÇ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂ ‚îÇ  üü™ GitHub Actions (CI)  ‚îÇ
‚îÇ  fonte do c√≥digo          ‚îÇ                                ‚îÇ  ci.yml: ruff+black+pytest‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                                ‚îÇ  + smoke: GET "/" na API ‚îÇ
                ‚îÇ Git Provider                               ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                ‚ñº                                                          smoke ‚îÉ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                                             (curl) ‚ñº
‚îÇ   ‚¨ú Render (Deploy)      ‚îÇ ‚óÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îÇ   build & publicar       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
           ‚îÇ
           ‚ñº
   (publica/atualiza)
   üüß FastAPI (Render)


========================
CryptoPulse ‚Äì Arquitetura
========================

1) Vis√£o Geral
--------------
- Frontend: Streamlit Cloud (dashboard p√∫blico) ou local.
- Backend: FastAPI hospedado no Render (servi√ßo web).
- Banco de Dados: Neon PostgreSQL (pooler gerenciado, SSL).
- Fonte de Dados: CoinGecko /simple/price (BTC/USD).
- ML: scikit-learn (pipeline simples, modelo salvo em models/model.pkl).
- CI: GitHub Actions (ci.yml) com lint (ruff), format check (black), testes (pytest) e smoke (GET / na API do Render).

2) Fluxo (alto n√≠vel)
---------------------
Usu√°rio -> (HTTPS) Streamlit -> (HTTP/JSON) FastAPI -> (SQLAlchemy) Postgres
                                     |
                                     +-> CoinGecko (coleta pre√ßo)

Batch de coleta roda no SERVIDOR (FastAPI) como background task.
Dashboard apenas inicia e acompanha o progresso (n√£o dispara N POSTS).

3) Endpoints (FastAPI)
----------------------
GET    /                      -> Health: {"ok": true, "service": "CryptoPulse"}
POST   /ingest                -> Coleta 1 leitura (CoinGecko) e faz upsert no DB
POST   /ingest_batch          -> Inicia batch no servidor (par√¢metros: count, delay)
GET    /batch/status          -> Retorna estado do batch: {running, done, fail, target}
POST   /batch/stop            -> Solicita parada graciosa do batch
GET    /data/last?n=300       -> √öltimas n leituras (para o dashboard)
POST   /train                 -> Treina o modelo (m√≠nimo 120 amostras); salva model.pkl
GET    /predict               -> Probabilidade de alta (janela de 5 min)

Notas:
- /ingest_batch roda um loop N vezes com "delay + jitter".
- /batch/status √© idempotente; pode ser chamado com frequ√™ncia pelo dashboard.

4) Banco de Dados (Neon Postgres)
---------------------------------
Tabelas:
- prices(ts_utc TEXT PRIMARY KEY, price_usd REAL NOT NULL)
- meta  (k TEXT PRIMARY KEY, v TEXT)

Observa√ß√µes:
- Upsert: INSERT ... ON CONFLICT (ts_utc) DO NOTHING
- Conex√£o: SQLAlchemy engine com pool_pre_ping=True, pool_recycle=180.
- URL: postgresql+psycopg://USER:PASSWORD@HOST/neondb?sslmode=require

5) Ingest√£o (app/ingestor.py)
-----------------------------
- requests.Session com Retry exponencial (429, 500, 502, 503, 504).
- backoff_factor ~0.7; respeita Retry-After quando presente.
- User-Agent pr√≥prio ("CryptoPulse/1.0 ...").
- polite_sleep(delay, jitter=¬±0.25s) para evitar bursts.

6) Batch Server-side
--------------------
- Iniciado por POST /ingest_batch?count=N&delay=S
- Executa como background task no processo do FastAPI (Render).
- Estado em mem√≥ria (BATCH_STATE: running/done/fail/target).
- /batch/stop ajusta target para encerrar o loop logo ap√≥s a itera√ß√£o atual.
- O dashboard apenas acompanha com GET /batch/status.

7) Treino/Predi√ß√£o (ML)
-----------------------
- M√≠nimo de 120 observa√ß√µes (sen√£o retorna "not_enough_data").
- Pipeline: StandardScaler + LogisticRegression (max_iter=1000).
- Split temporal: train/test com shuffle=False.
- Artefato salvo em models/model.pkl.
- Predict carrega artefato; retorna probabilidade de alta (horizonte 5 min).

8) UI (Streamlit)
-----------------
- Design System Gov.br (cores/tipografia Roboto) + √≠cones Font Awesome (em r√≥tulos).
- API_BASE:
  - Produ√ß√£o: vem de Secrets (Streamlit Cloud) e fica travado (read-only).
  - Local: var de ambiente API_BASE ou .streamlit/secrets.toml.
- Bot√µes principais: Coletar agora, Treinar, Iniciar/Parar lote, Predizer.
- Gr√°fico: Plotly (linha, cores DS Gov), m√©trica do √∫ltimo pre√ßo.
- Auto-refresh opcional (slider de intervalo).

9) CI (GitHub Actions)
----------------------
Arquivo: .github/workflows/ci.yml
- Python 3.11 (recomendado para wheels compat√≠veis).
- Instala requirements + ruff + black.
- ruff check, black --check, pytest -q.
- Smoke opcional: curl GET / na API do Render (usa secret RENDER_API_BASE).
- Concurrency: cancela pipelines antigos da mesma branch.

10) Makefile (dev local do dashboard)
-------------------------------------
- Objetivo principal: "make dash" para rodar Streamlit local usando API do Render.
- Vari√°veis:
  - RENDER_API_BASE=https://cryptopulse-okqa.onrender.com
  - PORT=8501
- Comando:
  API_BASE=$(RENDER_API_BASE) streamlit run dashboard/streamlit_app.py --server.port $(PORT)

11) Vari√°veis de Ambiente / Secrets
-----------------------------------
API (Render):
- DB_URL = postgresql+psycopg://USER:PASSWORD@HOST/neondb?sslmode=require

Dashboard (Streamlit Cloud) ‚Äì Secrets:
- API_BASE = "https://cryptopulse-okqa.onrender.com"

CI (GitHub) ‚Äì Secrets:
- RENDER_API_BASE = "https://cryptopulse-okqa.onrender.com"  (para smoke opcional)

12) Portas, CORS e Seguran√ßa
----------------------------
- FastAPI (Render) exposto via HTTPS pelo pr√≥prio Render.
- CORS configurado para aceitar https://*.streamlit.app (dashboard p√∫blico).
- Banco com SSL (sslmode=require).
- Nunca versionar secrets:
  - N√£o comitar .streamlit/secrets.toml em reposit√≥rios p√∫blicos.
  - DB_URL somente como ambiente no Render.

13) Limites e Resili√™ncia
-------------------------
- CoinGecko tem rate limits; usar delay >= 12s em batch (ajust√°vel).
- Retry com backoff para 429/5xx reduce falhas transit√≥rias.
- Render free pode "hibernar"; o dashboard faz healthcheck/warm-up.

14) Opera√ß√£o (Resumo)
---------------------
- Coleta manual: POST /ingest (via bot√£o ou curl).
- Coleta em lote: POST /ingest_batch (N, delay); monitorar /batch/status.
- Treino: POST /train (ap√≥s ‚â• 120 leituras).
- Predi√ß√£o: GET /predict.
- Dashboard: Streamlit consumindo a API p√∫blica do Render.


Fim

